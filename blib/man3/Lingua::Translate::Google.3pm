.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lingua::Translate::Google 3"
.TH Lingua::Translate::Google 3 "2008-11-16" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Lingua::Translate::Google 0.01 \- Translation back\-end for Google's beta translation service.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Lingua::Translate;
.Ve
.PP
.Vb 7
\& Lingua::Translate::config
\&     (
\&       backend => \(aqGoogle\(aq,
\&       api_key => \(aqYoUrApIkEy\(aq,
\&       referer => \(aqhttp://your.domain.tld/yourdir/\(aq,
\&       ua      => LWP::UserAgent\->new(),
\&     );
.Ve
.PP
.Vb 1
\& my $xl8r = Lingua::Translate\->new(src => \(aqde\(aq, dest => \(aqen\(aq);
.Ve
.PP
.Vb 2
\& # prints \(aqMy hovercraft is full of eels\(aq
\& print $xl8r\->translate(\(aqMein Luftkissenfahrzeug ist voller Aale\(aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Lingua::Translate::Google is a translation back-end for Lingua::Translate that contacts Google (http://ajax.googleapis.com/ajax/services/language/translate/) to do the real work.
.PP
It is normally invoked by Lingua::Translate; there should be no need to call it directly.  If you do call it directly, you will lose the ability to easily switch your programs over to alternate back-ends that are later produced.
.PP
If you omit the \s-1API\s0 key config option, then this module uses the fallback service at translate.google.com/ which works fine without it.
.PP
To use the Google APIs, Google asks that you obtain an \s-1API\s0 key, and that you always include a valid and accurate referer \s-1URL\s0. If you supply an \s-1API\s0 key, then this module uses the \s-1AJAX\s0 \s-1API\s0 which Google provides specifically for third party application development.
.PP
One way or another, by using Google services (either directly or via this module) you are agreeing by their terms of service.
.IP "Please read:" 4
.IX Item "Please read:"
http://www.google.com/accounts/TOS
.IP "To obtain your own \s-1API\s0 key:" 4
.IX Item "To obtain your own API key:"
http://code.google.com/apis/ajaxfeeds/signup.html
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .Sh "new(src => $lang, dest => lang)"
.el .Sh "new(src => \f(CW$lang\fP, dest => lang)"
.IX Subsection "new(src => $lang, dest => lang)"
.RS 4
Creates a new translation handle. 
Determines whether the requested language pair is available and will croak if not.
.RE
.PP
\fIparamters\fR
.IX Subsection "paramters"
.RS 4
.Sh "src"
.IX Subsection "src"
.RS 4
Source language, in \s-1RFC\-3066\s0 form.  See I18N::LangTags for a discussion of \s-1RFC\-3066\s0 language tags.
.RE
.RE
.RS 4
.Sh "dest"
.IX Subsection "dest"
.RS 4
Destination Language
.RE
.RE
.RS 4
.Sp
Other options that may be passed to the \fIconfig()\fR function (see below) may also be passed as arguments to this constructor.
.RE
.SH "METHODS"
.IX Header "METHODS"
The following methods may be called on Lingua::Translate::Google objects.
.ie n .Sh "\fIavailable()\fP : @list"
.el .Sh "\fIavailable()\fP : \f(CW@list\fP"
.IX Subsection "available() : @list"
.RS 4
Returns a list of available language pairs, in the form of '\s-1XX_YY\s0', where \s-1XX\s0 is the source language and \s-1YY\s0 is the destination. 
If you want the english name of a language tag, call \fII18N::LangTags::List::name()\fR on it.  See I18N::LangTags::List.
.Sp
This method contacts Google (http://translate.google.com/translate_a/t?) to calculate available language pairs. 
The data about available language pairs is cached in memory.
.RE
.ie n .Sh "translate($text) : $translated"
.el .Sh "translate($text) : \f(CW$translated\fP"
.IX Subsection "translate($text) : $translated"
.RS 4
Translates the given text, or die's on any kind of error. 
.Sp
It is assumed that the \f(CW$text\fR coming in is \s-1UTF\-8\s0 encoded, and that Google will be returning \s-1UTF\-8\s0 encoded text. In the case that Google returns some other encoding, then an attempt to convert the result to \s-1UTF\-8\s0 is made with Unicode::MapUTF8::to_utf8. Observation has indicated that the fallback service (at /translate_a/t) is inclined to return windows\-1255 encoded text, despite the value of the 'Accept\-Charset' header sent in the request. However, a non-windows user agent string seems to remedy this. 
.Sp
Also, the primary service (at googleapis.com) returns \s-1JSON\s0 which assumes the client is JavaScript running with an \s-1HTML\s0 document. This being the case strings are double encoded. First special characters are converted to \s-1HTML\s0 entities, and then the ampersands are converted to unicode escape sequences. For example, the string \*(L"Harold's\*(R" is encoded as \*(L"Harold\eu0027#39;s\*(R". The translate function attempts to return plain old \s-1UTF\-8\s0 encoded strings without any entities or escape sequences.
.RE
.Sh "\fIagent()\fP : LWP::UserAgent"
.IX Subsection "agent() : LWP::UserAgent"
.RS 4
Returns the LWP::UserAgent object used to contact Google.
.RE
.SH "CONFIGURATION FUNCTIONS"
.IX Header "CONFIGURATION FUNCTIONS"
.ie n .Sh "config( option => $value, )"
.el .Sh "config( option => \f(CW$value\fP, )"
.IX Subsection "config( option => $value, )"
This function sets defaults for use when constructing objects. Options include:
.RE
.IP "google_uri"
.IX Item "google_uri"
The uri to use when contacting Google.
.PP
The default value is
.PP
\&\*(L"http://ajax.googleapis.com/ajax/services/language/translate?\*(R"
     v=1.0
    &q=hello%20world
    &langpair=en%7Cit
    &key=yourapikey
.PP
For details see:
http://code.google.com/apis/ajaxlanguage/documentation/#fonje
.PP
Another possibility is:
.PP
\&\*(L"http://www.google.com/uds/Gtranslate?\*(R"
     v=1.0
    &q=hello%20world
    &langpair=en%7Czh\-TW
    &callback=google.language.callbacks.id101
    &context=22
    &key=notsupplied
    &key=yourapikey
.RE
.IP "google_fallback_uri"
.IX Item "google_fallback_uri"
The \s-1URI\s0 used when contacting Google, and no api_key is provided.
.PP
The default value is
.PP
\&\*(L"http://translate.google.com/translate_a/t?\*(R"
     client=t
    &text=hello%20world
    &sl=en
    &tl=zh\-Tw
.PP
Note, Google states clearly that they want you to obtain and use an \s-1API\s0 key, and also include a valid and accurate referer \s-1URL\s0.
.RE
.IP "agent"
.IX Item "agent"
The User-Agent string to use when contacting Google.
.PP
The default value is \*(L"Lingua::Translate::Google/\*(R", plus the version number of the package.
.RE
.IP "chunk_size"
.IX Item "chunk_size"
The size to break chunks into before handing them off to Google. The default value is \*(L"1000\*(R" (bytes).
.RE
.IP "retries"
.IX Item "retries"
The number of times to retry contacting Google if the first attempt fails. The default value is \*(L"2\*(R".
.SH "BUGS/TODO"
.IX Header "BUGS/TODO"
The chunk_size attribute is a hold-over from the Babelfish algorithm. It is \s-1TBD\s0 as to what chunk size ought to be set for Google.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Lingua::Translate, Lingua::Translate::Babelfish, LWP::UserAgent, Unicode::MapUTF8
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This is a rewritten copy of Lingua::Translate::Babelfish by Sam Vilain <enki@snowcra.sh>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dylan Doxey, <dylan.doxey@gmail.com>
